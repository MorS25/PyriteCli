using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using clipr;
using clipr.Core;
using PyriteLib;

namespace PyriteCli
{
    class Program
    {
		// Note: This will probably only work well with OBJ files generated by Pix4D
		// as I have only supported the subset of data types it outputs.
		static void Main(string[] args)
        {          
			Options opt;

			// Setup a timer for all operations
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();

			try
			{
				opt = CliParser.Parse<Options>(args);

				foreach (string path in opt.Input)
				{
					// Check if we are processing an image or a mesh
					if (Path.GetExtension(path).ToUpper().EndsWith("JPG"))
					{
						ImageTile tiler = new ImageTile(path, opt.XSize, opt.YSize);
						tiler.GenerateTiles(opt.OutputPath);
					}
					else if (Path.GetExtension(path).ToUpper().EndsWith("OBJ"))
					{
						// Generate subfolders named after input file
						// if multiple input files are provided
						string outputPath;
						if (opt.Input.Count == 1)
						{
							outputPath = opt.OutputPath;
						}
						else
						{
							outputPath = Path.Combine(opt.OutputPath, Path.GetFileNameWithoutExtension(path));
						}

						if (opt.ForceCubical)
						{
							int longestGridSide = Math.Max(Math.Max(opt.XSize, opt.YSize), opt.ZSize);
							opt.XSize = opt.YSize = opt.ZSize = longestGridSide;

							Console.WriteLine("Due to -ForceCubical grid size is now {0},{0},{0}", longestGridSide);
						}

                        var options = new SlicingOptions
                        {
                            OverrideMtl = opt.MtlOverride,
                            GenerateEbo = opt.Ebo,
                            GenerateOpenCtm =  opt.OpenCtm,
                            Debug = opt.Debug,
                            GenerateObj = true,
                            Texture = opt.Texture,
                            Obj = path,
                            TextureScale = opt.ScaleTexture,
                            TextureSliceX = opt.TextureXSize,
                            TextureSliceY = opt.TextureYSize,
                            ForceCubicalCubes = opt.ForceCubical,
                            CubeGrid = new Vector3 { X = opt.XSize, Y = opt.YSize, Z = opt.ZSize }
                        };

                        CubeManager manager = new CubeManager(options);

						if (opt.MarkupUV)
						{
							Texture tex = new Texture(manager.ObjInstance);
							tex.MarkupTextureFaces(opt.Texture);
						}
						else
						{
							manager.GenerateCubes(outputPath, options);
						}
					}
					else
					{
						Console.WriteLine("Cuber only accepts .jpg and .obj files for input.");
					}
				}
			}
			catch (ParserExit)
			{
				return;
			}
			catch (ParseException)
			{
				Console.WriteLine("usage: Cuber --help");
			}

			stopwatch.Stop();
			Trace.TraceInformation(stopwatch.Elapsed.ToString());
		}		
		
    }

	[ApplicationInfo(Description = "Cuber Options")]
	public class Options
	{
		[NamedArgument('x', "xsize", Action = ParseAction.Store,
			Description = "The number of times to subdivide in the X dimension.  Default 10.")]
		public int XSize { get; set; }

		[NamedArgument('y', "ysize", Action = ParseAction.Store,
			Description = "The number of times to subdivide in the Y dimension.  Default 10.")]
		public int YSize { get; set; }

		[NamedArgument('z', "zsize", Action = ParseAction.Store,
			Description = "The number of times to subdivide in the Z dimension.  Default 10.")]
		public int ZSize { get; set; }

		[NamedArgument('u', "texturex", Action = ParseAction.Store,
			Description = "The number of times to subdivide texture in the X dimension. Default 4.")]
		public int TextureXSize { get; set; }

		[NamedArgument('v', "texturey", Action = ParseAction.Store,
			Description = "The number of times to subdivide texture in the Y dimension. Default 4.")]
		public int TextureYSize { get; set; }

		[NamedArgument('s', "scaletexture", Action = ParseAction.Store,
			Description = "A number between 0 and 1 telling Cuber how to resize/scale the texture when using -t.  Default 1.")]
		public float ScaleTexture { get; set; }

		[NamedArgument('m', "mtl", Action = ParseAction.Store,
			Description = "Override the MTL field in output obj files. e.g. -z model.mtl")]
		public string MtlOverride { get; set; }

		[NamedArgument('t', "texture", Action = ParseAction.Store,
			Description = "Include a texture to partition during cube slicing. Will rewrite UV's in output files. Requires -tx -ty parameters.")]
		public string Texture { get; set; }

		[NamedArgument('e', "ebo", Action = ParseAction.StoreTrue,
			Description = "Generate EBO files designed for use with CubeServer in addition to OBJ files")]
		public bool Ebo { get; set; }

        [NamedArgument('p', "openctm", Action = ParseAction.StoreTrue,
            Description = "Generate OpenCtm files designed for use with CubeServer in addition to OBJ files")]
        public bool OpenCtm { get; set; }

		[NamedArgument('a', "markupUV", Action = ParseAction.StoreTrue,
			Description = "Draws UVW's on a texture")]
		public bool MarkupUV { get; set; }

		[NamedArgument('c', "forcecubical", Action = ParseAction.StoreTrue,
			Description = "X Y Z grid dimensions will be equal, and world space will be grown to fill a containing cube.")]
		public bool ForceCubical { get; set; }

		[NamedArgument('d', "debug", Action = ParseAction.StoreTrue,
			Description = "Generate various additional debug data during error states")]
		public bool Debug { get; set; }

		[PositionalArgument(0, MetaVar = "OUT",
			Description = "Output folder")]
		public string OutputPath { get; set; }

		[PositionalArgument(1, MetaVar = "IN",
			NumArgs = 1,
			Constraint = NumArgsConstraint.AtLeast,
			Description = "A list of .obj files to process")]
		public List<string> Input { get; set; }

		public Options()
		{
			XSize = 2;
			YSize = 2;
			ZSize = 2;
			ScaleTexture = 1;
			TextureXSize = 4;
			TextureYSize = 4;
			ForceCubical = true;
			Debug = false;
		}
	}

}
